/******************************************************************************
 *
 *  This file is part of the TULIPP Analysis Utility
 *
 *  Copyright 2018 Asbj√∏rn Djupdal, NTNU, TULIPP EU Project
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *****************************************************************************/

#include <assert.h>
#include <math.h>
#include <unistd.h>
#include <inttypes.h>

#include <QApplication>
#include <QTextStream>
#include <QMessageBox>
#include <QProgressDialog>
#include <QSettings>

#include "analysis_tool.h"
#include "project.h"
#include "location.h"

///////////////////////////////////////////////////////////////////////////////
// makefile creation

void Project::writeTulippCompileRule(QString compiler, QFile &makefile, QString path, QString opt) {
  QFileInfo fileInfo(path);

  QString clangTarget = A9_CLANG_TARGET;
  QString llcTarget = A9_LLC_TARGET;
  QString asTarget = A9_AS_TARGET;

  QString as = Config::as;

  if(ultrascale) {
    clangTarget = A53_CLANG_TARGET;
    llcTarget = A53_LLC_TARGET;
    asTarget = A53_AS_TARGET;

    as = Config::asUs;
  }

  // .ll
  {
    QStringList options;

    options << QString("-I") + this->path + "/src";

    options << opt.split(' ');

    if(cfgOptLevel >= 0) {
      options << QString("-O") + QString::number(cfgOptLevel);
    } else {
      options << QString("-Os");
    }
    options << clangTarget;

    makefile.write((fileInfo.baseName() + ".ll : " + path + "\n").toUtf8());
    makefile.write((QString("\t") + compiler + " " + options.join(' ') + " -g -emit-llvm -S $<\n\n").toUtf8());
  }

  // .xml
  {
    makefile.write((fileInfo.baseName() + ".xml : " + fileInfo.baseName() + ".ll\n").toUtf8());
    makefile.write((QString("\t") + Config::llvm_ir_parser + " $< -xml $@\n\n").toUtf8());
  }

  // _2.ll
  {
    makefile.write((fileInfo.baseName() + "_2.ll : " + fileInfo.baseName() + ".ll\n").toUtf8());
    makefile.write((QString("\t") + Config::llvm_ir_parser + " $< -ll $@\n\n").toUtf8());
  }

  // .s
  {
    QStringList options;
    if(cppOptLevel >= 0) {
      options << QString("-O") + QString::number(cppOptLevel);
    } else {
      options << QString("-Os");
    }
    options << QString(llcTarget).split(' ');

    makefile.write((fileInfo.baseName() + ".s : " + fileInfo.baseName() + "_2.ll\n").toUtf8());
    makefile.write((QString("\t") + Config::llc + " " + options.join(' ') + " $< -o $@\n\n").toUtf8());
  }

  // .o
  bool buildIt = true;
  for(auto acc : accelerators) {
    QFileInfo info(acc.filepath);
    if(info.baseName() == fileInfo.baseName()) {
      buildIt = false;
      break;
    }
  }
  if(buildIt) {
    QStringList options;
    options << QString(asTarget).split(' ');

    makefile.write((fileInfo.baseName() + ".o : " + fileInfo.baseName() + ".s\n").toUtf8());
    makefile.write((QString("\t") + as + " " + options.join(' ') + " $< -o $@\n\n").toUtf8());
  }

  makefile.write(QString("###############################################################################\n\n").toUtf8());
}

void Project::writeLinkRule(QString linker, QFile &makefile, QStringList objects) {
  makefile.write((name + ".elf : " + objects.join(' ') + "\n").toUtf8());
  makefile.write(QString("\t" + linker + " $^ " + linkerOptions + " -o $@\n\n").toUtf8());

  makefile.write(QString("###############################################################################\n\n").toUtf8());
}

bool Project::createXmlMakefile() {
  QStringList xmlFiles;

  QFile makefile("Makefile");
  bool success = makefile.open(QIODevice::WriteOnly);
  if(!success) {
    QMessageBox msgBox;
    msgBox.setText("Can't create Makefile");
    msgBox.exec();
    return false;
  }

  makefile.write(QString("###################################################\n").toUtf8());
  makefile.write(QString("# Autogenerated Makefile for TULIPP Analysis Tool #\n").toUtf8());
  makefile.write(QString("###################################################\n\n").toUtf8());

  makefile.write(QString(".PHONY : clean\n").toUtf8());
  makefile.write(QString("clean :\n").toUtf8());
  makefile.write(QString("\trm -rf *.ll *.xml *.s *.o *.elf *.bit sd_card _sds __tulipp__.* profile.prof __tulipp_test__.* .Xil\n\n").toUtf8());

  makefile.write(QString("###############################################################################\n\n").toUtf8());

  for(auto source : sources) {
    QFileInfo info(source);
    if(info.suffix() == "c") {
      writeTulippCompileRule(Config::clang, makefile, source, cOptions + " " + cSysInc);
      xmlFiles << info.baseName() + ".xml";
    } else if((info.suffix() == "cpp") || (info.suffix() == "cc")) {
      writeTulippCompileRule(Config::clangpp, makefile, source, cppOptions + " " + cppSysInc);
      xmlFiles << info.baseName() + ".xml";
    }
  }

  makefile.write(QString(".PHONY : xml\n").toUtf8());
  makefile.write((QString("xml : ") + xmlFiles.join(' ') + "\n").toUtf8());
  makefile.write(QString("\trm -rf profile.prof\n\n").toUtf8());

  makefile.write(QString("###############################################################################\n\n").toUtf8());

  makefile.close();

  return true;
}

void Project::writeCleanRule(QFile &makefile) {
  makefile.write(QString(".PHONY : clean\n").toUtf8());
  makefile.write(QString("clean :\n").toUtf8());
  makefile.write(QString("\trm -rf *.ll *.xml *.s *.o *.elf *.bit sd_card _sds __tulipp__.* profile.prof __tulipp_test__.* .Xil\n\n").toUtf8());

  makefile.write(QString("###############################################################################\n\n").toUtf8());
}

bool Project::createMakefile(QFile &makefile) {
  makefile.write(QString("###################################################\n").toUtf8());
  makefile.write(QString("# Autogenerated Makefile for TULIPP Analysis Tool #\n").toUtf8());
  makefile.write(QString("###################################################\n\n").toUtf8());

  makefile.write(QString(".PHONY : binary\n").toUtf8());
  makefile.write((QString("binary : ") + name + ".elf\n\n").toUtf8());

  makefile.write(QString("###############################################################################\n\n").toUtf8());

  writeCleanRule(makefile);

  return true;
}

///////////////////////////////////////////////////////////////////////////////
// make

void Project::makeXml() {
  emit advance(0, "Building XML");

  bool created = createXmlMakefile();
  if(created) errorCode = system(QString("make -j xml").toUtf8().constData());
  else errorCode = 1;

  if(!created || errorCode) {
    emit finished(errorCode, "Can't make XML");
  } else {
    emit finished(errorCode, "");
  }
}

void Project::makeBin() {
  emit advance(0, "Building XML");

  bool created = createXmlMakefile();
  if(created) errorCode = system(QString("make -j xml").toUtf8().constData());
  else errorCode = 1;

  if(!created || errorCode) {
    emit finished(errorCode, "Can't make XML");
    return;
  }

  loadFiles();

  emit advance(1, "Building binary");

  created = createMakefile();
  if(created) errorCode = system(QString("make -j binary").toUtf8().constData());
  else errorCode = 1;

  if(!created || errorCode) {
    emit finished(errorCode, "Can't make binary");
  } else {
    emit finished(errorCode, "");
  }
}

void Project::clean() {
  if(opened) {
    createXmlMakefile();
    errorCode = system("make clean");
  }
}

///////////////////////////////////////////////////////////////////////////////

void Project::loadProjectFile() {
  QSettings settings("project.ini", QSettings::IniFormat);

  cfgOptLevel = settings.value("cfgOptLevel", "-1").toInt();
  createBbInfo = settings.value("createBbInfo", true).toBool();
  systemXmls = settings.value("systemXmls").toStringList();
  for(unsigned i = 0; i < pmu.numSensors(); i++) {
    pmu.supplyVoltage[i] = settings.value("supplyVoltage" + QString::number(i), 5).toDouble();
  }
  pmu.rl[0] = settings.value("rl0", 0.025).toDouble();
  pmu.rl[1] = settings.value("rl1", 0.05).toDouble();
  pmu.rl[2] = settings.value("rl2", 0.05).toDouble();
  pmu.rl[3] = settings.value("rl3", 0.1).toDouble();
  pmu.rl[4] = settings.value("rl4", 0.1).toDouble();
  pmu.rl[5] = settings.value("rl5", 1).toDouble();
  pmu.rl[6] = settings.value("rl6", 10).toDouble();
  useCustomElf = settings.value("useCustomElf", false).toBool();
  customElfFile = settings.value("customElfFile", "").toString();
  startFunc = settings.value("startFunc", "main").toString();
  startCore = settings.value("startCore", 0).toUInt();
  stopFunc = settings.value("stopFunc", "_exit").toString();
  stopCore = settings.value("stopCore", 0).toUInt();

  if(!isSdSocProject()) {
    ultrascale = settings.value("ultrascale", true).toBool();
    sources = settings.value("sources").toStringList();
    cOptLevel = settings.value("cOptLevel", 0).toInt();
    cOptions = settings.value("cOptions", "").toString();
    cppOptLevel = settings.value("cppOptLevel", 0).toInt();
    cppOptions = settings.value("cppOptions", "").toString();
    linkerOptions = settings.value("linkerOptions", "").toString();
    tcfUploadScript = settings.value("tcfUploadScript", "").toString();

  } else {
    if(ultrascale) {
      tcfUploadScript = settings.value("tcfUploadScript", DEFAULT_TCF_UPLOAD_SCRIPT_US).toString();
    } else {
      tcfUploadScript = settings.value("tcfUploadScript", DEFAULT_TCF_UPLOAD_SCRIPT).toString();
    }
  }
}

void Project::saveProjectFile() {
  QSettings settings("project.ini", QSettings::IniFormat);

  settings.setValue("cfgOptLevel", cfgOptLevel);
  settings.setValue("createBbInfo", createBbInfo);
  settings.setValue("systemXmls", systemXmls);
  for(unsigned i = 0; i < pmu.numSensors(); i++) { 
    settings.setValue("supplyVoltage" + QString::number(i), pmu.supplyVoltage[i]);
    settings.setValue("rl" + QString::number(i), pmu.rl[i]);
  }
  settings.setValue("ultrascale", ultrascale);
  settings.setValue("tcfUploadScript", tcfUploadScript);
  settings.setValue("useCustomElf", useCustomElf);
  settings.setValue("customElfFile", customElfFile);
  settings.setValue("startFunc", startFunc);
  settings.setValue("startCore", startCore);
  settings.setValue("stopFunc", stopFunc);
  settings.setValue("stopCore", stopCore);

  settings.setValue("sources", sources);
  settings.setValue("cOptLevel", cOptLevel);
  settings.setValue("cOptions", cOptions);
  settings.setValue("cppOptLevel", cppOptLevel);
  settings.setValue("cppOptions", cppOptions);
  settings.setValue("linkerOptions", linkerOptions);
}

///////////////////////////////////////////////////////////////////////////////
// transform source

int Project::runSourceTool(QString inputFilename, QString outputFilename, QStringList loopsToPipeline, QString opt) {
  QStringList options;

  options << inputFilename;

  options << QString("-extra-arg=-I") + this->path + "/src";

  for(auto x : opt.split(' ')) {
    if(x.trimmed() != "") {
      options << QString("-extra-arg=") + x;
    }
  }

  for(auto l : loopsToPipeline) {
    options << QString("-pipeloop=") + l;
  }

  options << QString("-output " + outputFilename);

  options << QString("--");

  return system((Config::tulipp_source_tool + " " + options.join(' ')).toUtf8().constData());
}

///////////////////////////////////////////////////////////////////////////////
// project files

void Project::loadFiles() {
  if(cfgModel) delete cfgModel;
  cfgModel = new CfgModel();

  QDir dir(".");
  dir.setFilter(QDir::Files);

  // read system XML files
  for(auto filename : systemXmls) {
    if(filename != "") loadXmlFile(filename);
  }

  // read XML files from tulipp project dir
  {
    QStringList nameFilter;
    nameFilter << "*.xml";
    dir.setNameFilters(nameFilter);

    QFileInfoList list = dir.entryInfoList();
    for(auto fileInfo : list) {
      loadXmlFile(fileInfo.filePath());
    }
  }
}

void Project::loadXmlFile(const QString &fileName) {
  QDomDocument doc;
  QFile file(fileName);
  if(!file.open(QIODevice::ReadOnly)) {
    QMessageBox msgBox;
    msgBox.setText("File not found");
    msgBox.exec();
    return;
  }
  if(!doc.setContent(&file)) {
    QMessageBox msgBox;
    msgBox.setText("Invalid XML file");
    msgBox.exec();
    file.close();
    return;
  }
  file.close();

  try {
    cfgModel->addModule(doc, *this);
  } catch (std::exception &e) {
    QMessageBox msgBox;
    msgBox.setText("Invalid CFG file");
    msgBox.exec();
    return;
  }
}

///////////////////////////////////////////////////////////////////////////////
// object construction, destruction and management

Project::Project() {
  cfgModel = NULL;
  close();
}

void Project::copy(Project *p) {
  opened = p->opened;
  isCpp = p->isCpp;

  path = p->path;

  systemXmls = p->systemXmls;
  cfgOptLevel = p->cfgOptLevel;
  tcfUploadScript = p->tcfUploadScript;
  //pmu = p->pmu;
  ultrascale = p->ultrascale;
  startFunc = p->startFunc;
  startCore = p->startCore;
  stopFunc = p->stopFunc;
  stopCore = p->stopCore;
  createBbInfo = p->createBbInfo;
  useCustomElf = p->useCustomElf;
  
  // settings from either sdsoc project or user
  sources = p->sources;
  name = p->name;
  cOptions = p->cOptions;
  cOptLevel = p->cOptLevel;
  cppOptions = p->cppOptions;
  cppOptLevel = p->cppOptLevel;
  linkerOptions = p->linkerOptions;

  // settings from sdsoc project, unused otherwise
  configType = p->configType;
  accelerators = p->accelerators;
  cSysInc = p->cSysInc;
  cppSysInc = p->cppSysInc;
  
  QString customElfFile;
  elfFile = p->elfFile;

  cfgModel = NULL;
}

Project::Project(Project *p) {
  copy(p);
}

Project::~Project() {
  delete cfgModel;
}

void Project::close() {
  opened = false;
  isCpp = false;
  path = "";
  clear();
}

void Project::clear() {
  sources.clear();
  accelerators.clear();
  if(cfgModel) delete cfgModel;
  cfgModel = new CfgModel();
}

void Project::print() {
  printf("Project: %s\n", name.toUtf8().constData());
  printf("Path: %s\n", path.toUtf8().constData());

  printf("Files:\n");
  for(auto source : sources) {
    printf("  %s\n", source.toUtf8().constData());
  }

  printf("Accelerators:\n");
  for(auto acc : accelerators) {
    acc.print();
  }

  printf("C options: %s\n", cOptions.toUtf8().constData());
  printf("C opt level: %d\n", cOptLevel);
  printf("C++ options: %s\n", cppOptions.toUtf8().constData());
  printf("C++ opt level: %d\n", cppOptLevel);
  printf("Linker options: %s\n", linkerOptions.toUtf8().constData());

  printf("Architecture: %s\n", ultrascale ? "Zynq Ultrascale+" : "Zynq");
}

///////////////////////////////////////////////////////////////////////////////
// profiling support

void Project::runProfiler() {

  ElfSupport elfSupport(elfFile);
  if(useCustomElf) {
    elfSupport = ElfSupport(customElfFile);
  }

  bool pmuInited = pmu.init();
  if(!pmuInited) {
    emit finished(1, "Can't connect to PMU");
    return;
  }

  emit advance(0, "Uploading binary");

  // upload binaries
  QFile tclFile("temp-pmu-prof.tcl");
  bool success = tclFile.open(QIODevice::WriteOnly);
  Q_UNUSED(success);
  assert(success);

  QString tcl = QString() + "set name " + name + "\n" + tcfUploadScript;
      
  tclFile.write(tcl.toUtf8());

  tclFile.close();

  int ret = system("xsct temp-pmu-prof.tcl");
  if(ret) {
    emit finished(1, "Can't upload binaries");
    pmu.release();
    return;
  }

  // // collect samples
  {
    emit advance(1, "Collecting samples");
    pmu.collectSamples(startCore, elfSupport.lookupSymbol(startFunc), stopCore, elfSupport.lookupSymbol(stopFunc));
  }

  {
    emit advance(2, "Processing samples");

    std::map<BasicBlock*,Location*> locations[LYNSYN_MAX_CORES];
    unsigned locationId = 0;

    printf("Querying samples\n");

    QSqlQuery query;
    query.setForwardOnly(true);
    query.exec("SELECT core.rowid,core.core,core.pc,sensor.sensor,sensor.timeSinceLast,sensor.power FROM core JOIN sensor"
               " WHERE core.time = sensor.time");

    int counter = 0;

    QSqlDatabase::database().transaction();

    QSqlQuery updateQuery;
    updateQuery.prepare("UPDATE core SET location = :location WHERE rowid = :rowid");

    while(query.next()) {
      if((counter++ % 10000) == 0) printf("Processed %d samples...\n", counter);

      unsigned core = query.value("core").toUInt();
      uint64_t pc = query.value("pc").toULongLong();
      unsigned sensor = query.value("sensor").toUInt();
      int64_t timeSinceLast = query.value("timeSinceLast").toLongLong();
      double power = query.value("power").toDouble();

      BasicBlock *bb = NULL;
      Function *func = NULL;

      if(!useCustomElf && elfSupport.isBb(pc)) {
        Module *mod = cfgModel->getCfg()->getModuleById(elfSupport.getModuleId(pc));
        if(mod) bb = mod->getBasicBlockById(QString::number(elfSupport.getLineNumber(pc)));

      } else {
        func = cfgModel->getCfg()->getFunctionById(elfSupport.getFunction(pc));

        if(func) {
          // we don't know the BB, but the function exists in the CFG: add to first BB
          bb = func->getFirstBb();
          func = NULL;

        } else {
          // the function does not exist in the CFG
          Module *mod = cfgModel->getCfg()->externalMod;
          func = mod->getFunctionById(elfSupport.getFunction(pc));

          if(func) {
            bb = static_cast<BasicBlock*>(func->children[0]);
          } else {
            func = new Function(elfSupport.getFunction(pc), mod, mod->children.size());
            mod->appendChild(func);

            bb = new BasicBlock(QString::number(mod->children.size()), func, 0);
            func->appendChild(bb);
          }
        }
      }

      QString modText = "";
      QString funcText = "";
      QString bbText = "";

      if(func) {
        funcText = func->id;
      }

      assert(bb);

      bbText = bb->id;
      modText = bb->getModule()->id;

      Location *location;
      auto it = locations[core].find(bb);
      if(it != locations[core].end()) {
        location = it->second;
      } else {
        location = new Location(locationId++, modText, funcText, bbText);
        locations[core][bb] = location;
      }

      if(sensor == 0) location->runtime += Pmu::cyclesToSeconds(timeSinceLast);
      location->energy[sensor] += power * Pmu::cyclesToSeconds(timeSinceLast);

      unsigned rowId = query.value("rowid").toUInt();
      updateQuery.bindValue(":rowid", rowId);
      updateQuery.bindValue(":location", location->id);
      bool success = updateQuery.exec();
      assert(success);
    }

    QSqlDatabase::database().commit();

    QSqlDatabase::database().transaction();

    printf("Storing locations\n");

    for(unsigned c = 0; c < LYNSYN_MAX_CORES; c++) {
      for(auto location : locations[c]) {
        QSqlQuery query;

        query.prepare("INSERT INTO location (id,core,basicblock,function,module,runtime,energy1,energy2,energy3,energy4,energy5,energy6,energy7) "
                      "VALUES (:id,:core,:basicblock,:function,:module,:runtime,:energy1,:energy2,:energy3,:energy4,:energy5,:energy6,:energy7)");

        query.bindValue(":id", location.second->id);
        query.bindValue(":core", c);
        query.bindValue(":basicblock", location.second->bbId);
        query.bindValue(":function", location.second->funcId);
        query.bindValue(":module", location.second->moduleId);
        query.bindValue(":runtime", location.second->runtime);
        query.bindValue(":energy1", location.second->energy[0]);
        query.bindValue(":energy2", location.second->energy[1]);
        query.bindValue(":energy3", location.second->energy[2]);
        query.bindValue(":energy4", location.second->energy[3]);
        query.bindValue(":energy5", location.second->energy[4]);
        query.bindValue(":energy6", location.second->energy[5]);
        query.bindValue(":energy7", location.second->energy[6]);

        bool success = query.exec();
        assert(success);

        delete location.second;
      }
    }

    QSqlDatabase::database().commit();

    uint64_t samples;
    int64_t minTime;
    int64_t maxTime;
    double minPower[LYNSYN_SENSORS];
    double maxPower[LYNSYN_SENSORS];

    printf("Querying minmax time\n");

    query.exec(QString() + "SELECT MIN(time),MAX(time) FROM sensor");
    if(query.next()) {
      minTime = query.value(0).toLongLong();
      maxTime = query.value(1).toLongLong();
    }

    printf("Querying count,minmax power\n");

    for(int i = 0; i < LYNSYN_SENSORS; i++) {
      query.exec(QString() + "SELECT COUNT(*),MIN(power),MAX(power) FROM sensor WHERE sensor = " + QString::number(i));
      if(query.next()) {
        samples = query.value(0).toULongLong();
        minPower[i] = query.value(1).toDouble();
        maxPower[i] = query.value(2).toDouble();
      }
    }

    QSqlDatabase::database().transaction();

    printf("storing meta\n");

    query.prepare("INSERT INTO meta (samples,minTime,maxTime,minPower1,minPower2,minPower3,minPower4,minPower5,minPower6,minPower7,maxPower1,maxPower2,maxPower3,maxPower4,maxPower5,maxPower6,maxPower7) VALUES (:samples,:minTime,:maxTime,:minPower1,:minPower2,:minPower3,:minPower4,:minPower5,:minPower6,:minPower7,:maxPower1,:maxPower2,:maxPower3,:maxPower4,:maxPower5,:maxPower6,:maxPower7)");

    query.bindValue(":samples", (quint64)samples);
    query.bindValue(":minTime", (qint64)minTime);
    query.bindValue(":maxTime", (qint64)maxTime);
    query.bindValue(":minPower1", minPower[0]);
    query.bindValue(":minPower2", minPower[1]);
    query.bindValue(":minPower3", minPower[2]);
    query.bindValue(":minPower4", minPower[3]);
    query.bindValue(":minPower5", minPower[4]);
    query.bindValue(":minPower6", minPower[5]);
    query.bindValue(":minPower7", minPower[6]);
    query.bindValue(":maxPower1", maxPower[0]);
    query.bindValue(":maxPower2", maxPower[1]);
    query.bindValue(":maxPower3", maxPower[2]);
    query.bindValue(":maxPower4", maxPower[3]);
    query.bindValue(":maxPower5", maxPower[4]);
    query.bindValue(":maxPower6", maxPower[5]);
    query.bindValue(":maxPower7", maxPower[6]);

    bool success = query.exec();
    assert(success);

    QSqlDatabase::database().commit();
  }

  pmu.release();

  emit finished(0, "");
}

///////////////////////////////////////////////////////////////////////////////

Cfg *Project::getCfg() {
  return cfgModel->getCfg();
}

